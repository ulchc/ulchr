% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/which_rows.R
\name{which_rows}
\alias{which_rows}
\title{Return matching row indices}
\usage{
which_rows(
  data,
  scan_cols = 1:ncol(data),
  contain_strings = NULL,
  all_strings = TRUE,
  case_sensitive = TRUE,
  lack_na = TRUE,
  flatten = TRUE
)
}
\arguments{
\item{data}{Input data frame or tibble.}

\item{scan_cols}{The column indices that will have their row values combined and searched for matches
(\emph{see Details section}).}

\item{contain_strings}{A single string or character list.}

\item{all_strings}{If `TRUE`, return index where all strings present. If `FALSE`,
return the index of any row with at least one matching string.}

\item{case_sensitive}{If `FALSE`, pattern case is ignored. If `TRUE`, pattern case is considered.}

\item{lack_na}{If `TRUE`, do not return row indices which have `NA` values in any of the \code{scan_cols}.
If `FALSE`, permit the return of indices with `NA` values.}

\item{flatten}{If `TRUE`, return an integer vector of each unique index. If `FALSE`,
return a named list of indices.}
}
\value{
An integer vectors or list of integer vectors.
}
\description{
For cleaning data with inconsistent formatting, but consistent identifying
characters somewhere within each row. For use in situations like:
* to detect the header row of an Excel sheet when it is always the first row without NA values
* to select rows by index when it is known that a valid row contains an identifying character or
string, but the column to search isn't consistent
* to normalize flattened data when more than one character or string must be used to
categorize a row value as a certain column attribute
}
\details{
Combines the row values of any number of
columns into a single string separated by a space (" ") and returns the indices
which pass the conditions of the arguments.
}
\examples{
library(tidyr)
library(dplyr)

# Generate Data -------------------------------
set.seed(1)
data <- tidyr::table2
n_rows <- sample(nrow(data), 5)
data[n_rows, 1] <- table2[n_rows, 3]
data[n_rows, 3] <- table2[n_rows, 1]

data # where type & country columns mismatched

# EX. 1 ---------------------------------------
row_index <-
  which_rows(
    data,
    contain_strings = c("CASES", "2000"),
    all_strings = TRUE,
    case_sensitive = FALSE,
    flatten = TRUE
  )

# NOTE: able to directly subset because flatten = TRUE

# 3 rows returned which correspond with cases in 2000
data[row_index, ]
# 2 rows returned 1 missed with filter due to column misalignment
data \%>\% filter(type == "cases" & year == 2000)

# EX. 2 ---------------------------------------
row_indices <-
  which_rows(
    data,
    contain_strings = c("1999", "population"),
    all_strings = FALSE,
    flatten = FALSE
  )

# NOTE: list returned because flatten = FALSE

# where "1999" occurs in string of row vals
data[row_indices$`contains string: '1999'`, ]
# where "population" occurs in string of row vals
data[row_indices$`contains string: 'population'`, ]

# EX. 3 ---------------------------------------
row_index_alt <-
  which_rows(
    data,
    # which_rows combines cols for each row separated by " "
    contain_strings = c("1999 population"),
    all_strings = TRUE,
    flatten = TRUE
  )

# cases where "1999" was found immediately to the left of "population"
data[row_index_alt, ]
}
